import { ethers } from 'ethers';
import fs from 'fs/promises';
import path from 'path';
import dotenv from 'dotenv';

// Charger les variables d'environnement
dotenv.config({ path: path.resolve(process.cwd(), '.env') });

const {
    BNB_RPC_URL,
    OPERATOR_PRIVATE_KEY
} = process.env;

// Adresse du contrat onboarding
const ONBOARDING_CONTRACT_ADDRESS = "0xf3af730B6eaF257EC44b244d56F3073Fd6B593c5";

// ABI pour les fonctions n√©cessaires
const onboardingABI = [
    "function executeDailySwap(address user) external",
    "function getUserOnboardingStatus(address user) external view returns (bool,bool,uint256,uint256,uint8,uint256)"
];

// Chemin vers les fichiers de donn√©es
const USERS_FILE_PATH = path.resolve(process.cwd(), 'data/users.json');
const PENDING_ACTIONS_FILE_PATH = path.resolve(process.cwd(), 'data/pending-actions.json');

// Initialiser le provider et le wallet
const provider = new ethers.JsonRpcProvider(BNB_RPC_URL);
const operatorWallet = new ethers.Wallet(OPERATOR_PRIVATE_KEY, provider);
const onboardingContract = new ethers.Contract(ONBOARDING_CONTRACT_ADDRESS, onboardingABI, operatorWallet);

// Types d'actions
const ACTION_TYPES = {
    DAILY_SWAP: 'daily_swap',
    P2P_TRANSFER: 'p2p_transfer',
    PREMIUM_SUBSCRIPTION: 'premium_subscription'
};

// Seuil pour d√©clencher le batch
const BATCH_THRESHOLD = 3;

/**
 * Initialise le fichier des actions en attente s'il n'existe pas
 */
async function initializePendingActionsFile() {
    try {
        await fs.access(PENDING_ACTIONS_FILE_PATH);
    } catch {
        // Fichier n'existe pas, le cr√©er
        const initialData = {
            users: {},
            lastUpdated: new Date().toISOString()
        };
        await fs.writeFile(PENDING_ACTIONS_FILE_PATH, JSON.stringify(initialData, null, 2));
    }
}

/**
 * Lit les actions en attente
 */
async function getPendingActions() {
    try {
        const data = await fs.readFile(PENDING_ACTIONS_FILE_PATH, 'utf8');
        return JSON.parse(data);
    } catch (error) {
        console.error('Erreur lecture actions en attente:', error);
        return { users: {}, lastUpdated: new Date().toISOString() };
    }
}

/**
 * Sauvegarde les actions en attente
 */
async function savePendingActions(actions) {
    try {
        actions.lastUpdated = new Date().toISOString();
        await fs.writeFile(PENDING_ACTIONS_FILE_PATH, JSON.stringify(actions, null, 2));
    } catch (error) {
        console.error('Erreur sauvegarde actions en attente:', error);
    }
}

/**
 * Ajoute une action en attente pour un utilisateur
 */
async function addPendingAction(userAddress, actionType, actionData = {}) {
    await initializePendingActionsFile();
    const actions = await getPendingActions();

    if (!actions.users[userAddress]) {
        actions.users[userAddress] = [];
    }

    const action = {
        id: Date.now() + Math.random(),
        type: actionType,
        data: actionData,
        createdAt: new Date().toISOString(),
        status: 'pending'
    };

    actions.users[userAddress].push(action);
    await savePendingActions(actions);

    console.log(`üìù Action ${actionType} ajout√©e pour ${userAddress}`);

    // V√©rifier si on peut d√©clencher le batch
    await checkAndTriggerBatch(userAddress);

    return action;
}

/**
 * V√©rifie et d√©clenche le batch si le seuil est atteint
 */
async function checkAndTriggerBatch(userAddress) {
    const actions = await getPendingActions();
    const userActions = actions.users[userAddress] || [];
    const pendingActions = userActions.filter(a => a.status === 'pending');

    console.log(`üîç ${userAddress}: ${pendingActions.length} actions en attente`);

    if (pendingActions.length >= BATCH_THRESHOLD) {
        console.log(`üöÄ Seuil atteint! D√©clenchement du batch pour ${userAddress}`);
        await executeBatch(userAddress);
    }
}

/**
 * Force l'ex√©cution imm√©diate des actions en attente (ignore le seuil)
 */
async function forceExecuteBatch(userAddress) {
    console.log(`‚ö° EX√âCUTION FORC√âE DU BATCH pour ${userAddress}`);
    console.log('===============================================');

    const actions = await getPendingActions();
    const userActions = actions.users[userAddress] || [];
    const pendingActions = userActions.filter(a => a.status === 'pending');

    if (pendingActions.length === 0) {
        console.log('‚ÑπÔ∏è Aucune action en attente √† ex√©cuter');
        return { executed: 0, message: 'Aucune action en attente' };
    }

    console.log(`üîß For√ßage de ${pendingActions.length} actions (seuil ignor√©)`);
    await executeBatch(userAddress);

    return {
        executed: pendingActions.length,
        message: `${pendingActions.length} actions ex√©cut√©es imm√©diatement`
    };
}

/**
 * Ex√©cute une seule action sp√©cifique imm√©diatement
 */
async function executeSingleAction(userAddress, actionId) {
    console.log(`üéØ EX√âCUTION UNIQUE pour ${userAddress} - Action: ${actionId}`);

    const actions = await getPendingActions();
    const userActions = actions.users[userAddress] || [];
    const action = userActions.find(a => a.id == actionId && a.status === 'pending');

    if (!action) {
        console.log('‚ùå Action non trouv√©e ou d√©j√† trait√©e');
        return { success: false, message: 'Action non trouv√©e' };
    }

    try {
        console.log(`üîÑ Ex√©cution de: ${action.type}`);
        const success = await executeAction(userAddress, action);

        if (success) {
            action.status = 'completed';
            action.completedAt = new Date().toISOString();
            console.log(`‚úÖ Action ex√©cut√©e avec succ√®s`);
        } else {
            action.status = 'failed';
            action.failedAt = new Date().toISOString();
            console.log(`‚ùå √âchec de l'ex√©cution`);
        }

        await savePendingActions(actions);

        return {
            success,
            actionType: action.type,
            message: success ? 'Action ex√©cut√©e' : '√âchec de l\'ex√©cution'
        };

    } catch (error) {
        console.error('‚ùå Erreur ex√©cution unique:', error.message);
        action.status = 'failed';
        action.error = error.message;
        await savePendingActions(actions);

        return { success: false, message: error.message };
    }
}

/**
 * Ex√©cute toutes les actions en attente pour un utilisateur
 */
async function executeBatch(userAddress) {
    console.log(`üîÑ EX√âCUTION DU BATCH pour ${userAddress}`);
    console.log('=====================================');

    const actions = await getPendingActions();
    const userActions = actions.users[userAddress] || [];
    const pendingActions = userActions.filter(a => a.status === 'pending');

    if (pendingActions.length === 0) {
        console.log('‚ÑπÔ∏è Aucune action en attente');
        return;
    }

    let successfulActions = 0;
    let failedActions = 0;

    for (const action of pendingActions) {
        try {
            console.log(`üîÑ Ex√©cution: ${action.type}`);

            const success = await executeAction(userAddress, action);

            if (success) {
                action.status = 'completed';
                action.completedAt = new Date().toISOString();
                successfulActions++;
                console.log(`‚úÖ ${action.type} r√©ussi`);
            } else {
                action.status = 'failed';
                action.failedAt = new Date().toISOString();
                failedActions++;
                console.log(`‚ùå ${action.type} √©chou√©`);
            }

        } catch (error) {
            console.error(`‚ùå Erreur ex√©cution ${action.type}:`, error.message);
            action.status = 'failed';
            action.error = error.message;
            failedActions++;
        }
    }

    // Sauvegarder les r√©sultats
    await savePendingActions(actions);

    console.log('');
    console.log('üìä R√âSULTATS DU BATCH:');
    console.log(`‚úÖ Actions r√©ussies: ${successfulActions}`);
    console.log(`‚ùå Actions √©chou√©es: ${failedActions}`);
    console.log(`üìã Total trait√©: ${successfulActions + failedActions}`);

    // Nettoyer les actions anciennes (garder seulement les 10 derni√®res)
    await cleanupOldActions(userAddress);
}

/**
 * Ex√©cute une action sp√©cifique
 */
async function executeAction(userAddress, action) {
    switch (action.type) {
        case ACTION_TYPES.DAILY_SWAP:
            return await executeDailySwap(userAddress);

        case ACTION_TYPES.P2P_TRANSFER:
            return await executeP2PTransfer(userAddress, action.data);

        case ACTION_TYPES.PREMIUM_SUBSCRIPTION:
            return await executePremiumSubscription(userAddress, action.data);

        default:
            console.log(`‚ö†Ô∏è Type d'action inconnu: ${action.type}`);
            return false;
    }
}

/**
 * Ex√©cute un swap quotidien
 */
async function executeDailySwap(userAddress) {
    try {
        // V√©rifier le statut d'onboarding
        const status = await onboardingContract.getUserOnboardingStatus(userAddress);
        const [isActive, completed] = status;

        if (!isActive || completed) {
            console.log(`‚ö†Ô∏è Utilisateur inactif ou onboarding termin√©`);
            return false;
        }

        // Ex√©cuter le swap
        const tx = await onboardingContract.executeDailySwap(userAddress);
        await tx.wait();

        console.log(`üí± Swap quotidien ex√©cut√© - Hash: ${tx.hash}`);
        return true;

    } catch (error) {
        console.error('Erreur swap quotidien:', error.message);
        return false;
    }
}

/**
 * Ex√©cute un transfert P2P (placeholder - √† impl√©menter)
 */
async function executeP2PTransfer(userAddress, transferData) {
    try {
        // TODO: Impl√©menter la logique de transfert P2P
        console.log(`üí∏ Transfert P2P simul√©: ${transferData.amount} vers ${transferData.recipient}`);
        // Ici on int√©grera la vraie logique de P2P
        return true;
    } catch (error) {
        console.error('Erreur transfert P2P:', error.message);
        return false;
    }
}

/**
 * Ex√©cute une souscription premium (placeholder - √† impl√©menter)
 */
async function executePremiumSubscription(userAddress, subscriptionData) {
    try {
        // TODO: Impl√©menter la logique de souscription premium
        console.log(`‚≠ê Souscription premium simul√©e: ${subscriptionData.plan}`);
        // Ici on int√©grera la vraie logique premium
        return true;
    } catch (error) {
        console.error('Erreur souscription premium:', error.message);
        return false;
    }
}

/**
 * Nettoie les anciennes actions (garde seulement les 10 derni√®res)
 */
async function cleanupOldActions(userAddress) {
    const actions = await getPendingActions();
    const userActions = actions.users[userAddress] || [];

    if (userActions.length > 10) {
        // Trier par date et garder les 10 plus r√©centes
        userActions.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
        actions.users[userAddress] = userActions.slice(0, 10);
        await savePendingActions(actions);
        console.log('üßπ Actions anciennes nettoy√©es');
    }
}

/**
 * Obtient le statut des actions en attente pour un utilisateur
 */
async function getPendingActionsStatus(userAddress) {
    const actions = await getPendingActions();
    const userActions = actions.users[userAddress] || [];
    const pending = userActions.filter(a => a.status === 'pending');

    return {
        total: userActions.length,
        pending: pending.length,
        completed: userActions.filter(a => a.status === 'completed').length,
        failed: userActions.filter(a => a.status === 'failed').length,
        canTriggerBatch: pending.length >= BATCH_THRESHOLD
    };
}

/**
 * D√©clenche manuellement le batch pour un utilisateur
 */
async function triggerManualBatch(userAddress) {
    console.log(`üîß D√©clenchement manuel du batch pour ${userAddress}`);
    await executeBatch(userAddress);
}

/**
 * Ajoute automatiquement les swaps quotidiens manqu√©s
 */
async function addMissedDailySwaps() {
    console.log('üîç Recherche des swaps quotidiens manqu√©s...');

    try {
        const usersData = await fs.readFile(USERS_FILE_PATH, 'utf8');
        const users = JSON.parse(usersData);
        const activeUsers = users.filter(u => u.isActive);

        for (const user of activeUsers) {
            const missedDays = calculateMissedDays(user);

            if (missedDays > 0) {
                console.log(`üìÖ ${user.address}: ${missedDays} swaps manqu√©s`);

                // Ajouter les swaps manqu√©s comme actions en attente
                for (let i = 0; i < missedDays; i++) {
                    await addPendingAction(user.address, ACTION_TYPES.DAILY_SWAP, {
                        day: i + 1,
                        reason: 'missed_daily_swap'
                    });
                }
            }
        }

        console.log('‚úÖ Swaps manqu√©s ajout√©s au syst√®me de batch');

    } catch (error) {
        console.error('Erreur ajout swaps manqu√©s:', error);
    }
}

/**
 * Calcule le nombre de jours de swap manqu√©s
 */
function calculateMissedDays(user) {
    const now = new Date();
    const lastSwap = new Date(user.lastDailySwap || user.onboardingStartDate);

    // Calcul plus pr√©cis en utilisant les dates sans les heures
    const nowDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const lastSwapDate = new Date(lastSwap.getFullYear(), lastSwap.getMonth(), lastSwap.getDate());

    const daysSinceLastSwap = Math.floor((nowDate - lastSwapDate) / (1000 * 60 * 60 * 24));

    // Retourner le nombre de jours manqu√©s (daysSinceLastSwap - 1 car le dernier jour ne compte pas)
    return Math.min(Math.max(0, daysSinceLastSwap - 1), 7); // Max 7 jours
}

export {
    addPendingAction,
    executeBatch,
    getPendingActionsStatus,
    triggerManualBatch,
    addMissedDailySwaps,
    forceExecuteBatch,
    executeSingleAction,
    ACTION_TYPES,
    BATCH_THRESHOLD
};